.tableScrollContent {
  display: flex;
  flex-direction: column;
  width: 100%;
  min-width: 0;
  /* Match wrapper so any gap to the right is not transparent (no purple stripe showing through) */
  background-color: var(--colorNeutralBackground1, #ffffff);
}

.tableWidthAnchor {
  /* When table fits (data-auto-fit): fill 100% so last column gets space. When overflow: size to content for scroll. */
  width: max-content;
  min-width: max(100%, var(--data-table-total-min-width, 0px));
  background-color: var(--colorNeutralBackground1, #ffffff);
}

/* When table fits in container: fill full width so columns (including Tags) use the space, no dead zone on the right */
.tableWrapper[data-auto-fit='true'] .tableWidthAnchor {
  width: 100%;
}

/* Always use full container width (matches pagination); columns fill the space */
.tableWrapper {
  /* Default: no horizontal scroll unless we explicitly allow overflow (wide tables). */
  overflow-x: hidden;
  overflow-y: visible;
  width: 100%;
  max-width: 100%;
  margin-bottom: 15px;
  border-radius: var(--borderRadiusMedium, 4px);
  box-sizing: border-box;
  /* Border is applied to the grid itself so we don't draw an empty bordered area
     when the grid content is narrower than the container. */
  border: none;
  -webkit-overflow-scrolling: touch;

  /* Wide tables: allow horizontal scroll */
  &[data-overflow-x='true'] {
    overflow-x: auto;
  }

  /* Empty state: no horizontal scroll – can't scroll right into white space */
  &[data-empty='true'] {
    overflow-x: hidden;
  }

  /* Scoped by data-column-count so our overrides apply; variable is set on this wrapper */
  &[data-column-count] :global {
    /* Let the grid/table size to its content.
       This avoids “last column becomes a giant spacer” when the container is wider than the columns,
       and keeps header actions (sort/filter) from drifting all the way to the far right.
       The wrapper still stays width:100% so pagination aligns. */
    .fui-DataGrid {
      /* Width behavior is controlled by a CSS var from the React wrapper. */
      width: var(--data-table-width, fit-content) !important;
      max-width: 100% !important;
      min-width: var(--data-table-min-width, max-content) !important;
      box-sizing: border-box !important;

      /* Visual container border belongs to the grid (not the full-width wrapper). */
      border: 1px solid var(--colorNeutralStroke2, #e0e0e0) !important;
      border-radius: var(--borderRadiusMedium, 4px) !important;
      overflow: hidden;
    }

    /* Use auto layout so Fluent sizing/resize works naturally. */
    .fui-DataGrid .fui-Table {
      width: var(--data-table-width, fit-content) !important;
      max-width: 100% !important;
      min-width: var(--data-table-min-width, max-content) !important;
      table-layout: auto !important;
      box-sizing: border-box !important;
      border: none !important;
      outline: none !important;
    }

    /* Rows span full table width */
    .fui-DataGrid .fui-TableRow,
    .fui-DataGrid .fui-DataGridRow {
      width: 100% !important;
      min-width: 100% !important;
    }

    .fui-DataGridHeader {
      background-color: var(--colorSubtleBackgroundSelected, #f3f2f1);
    }

    /* Let Fluent's column sizing system own widths (resizableColumns + columnSizingOptions).
       We only enforce a min-width + sane box sizing. */
    .fui-DataGridHeaderCell,
    .fui-DataGridCell {
      /* Do NOT use !important here: Fluent sets inline width/min/max during resize. */
      min-width: 80px;
      box-sizing: border-box !important;
    }

    .fui-DataGridHeaderCell {
      min-width: var(--data-table-cell-min-width, 80px);
      white-space: nowrap !important;
      position: relative;
      background-color: var(--colorSubtleBackgroundSelected, #f3f2f1);
      font-size: 14px;
      border-right: 1px solid var(--colorNeutralStroke1, #c4c4c4);
    }

    /* No extra right border on last column – wrapper provides right edge (row may have trailing <i> so use last-of-type) */
    .fui-DataGridHeader .fui-DataGridRow .fui-DataGridHeaderCell:last-of-type,
    .fui-DataGridBody .fui-DataGridRow .fui-DataGridCell:last-of-type {
      border-right: none !important;
    }

    .fui-DataGridCell {
      min-width: var(--data-table-cell-min-width, 80px);
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      font-size: 12px;
      border-right: 1px solid var(--colorNeutralStroke1, #c4c4c4);

      /* Prevent long unbroken content from forcing intrinsic widths / overlap */
      > * {
        min-width: 0;
      }

      .fui-TableCellLayout {
        font-size: 12px;
      }
    }

    /* Resize handle: contained so focus ring doesn’t create a purple stripe to the right */
    .fui-DataGridHeaderCell__aside {
      display: flex !important;
      cursor: col-resize !important;
      position: absolute !important;
      right: 0 !important;
      top: 0 !important;
      bottom: 0 !important;
      width: 16px !important;
      z-index: 1 !important;
      outline: none !important;
      border-radius: 0 !important;
    }

    /* Fix: Fluent renders a resize handle on the last header cell.
       The handle has negative horizontal margins (hit target), which bleeds past the table edge
       and makes the last header look like it has extra space vs the body cells.
       Hide the resize affordance on the last column header. */
    .fui-DataGridHeader .fui-DataGridRow .fui-DataGridHeaderCell:last-of-type {
      .fui-DataGridHeaderCell__aside,
      .fui-TableResizeHandle {
        display: none !important;
      }
    }

    /* No extra bottom border: last row (row + cells) – wrapper provides bottom edge so no double line */
    .fui-DataGridBody .fui-DataGridRow:last-child {
      border-bottom: none !important;
    }
    .fui-DataGridBody .fui-DataGridRow:last-child .fui-DataGridCell {
      border-bottom: none !important;
    }

    .fui-Link {
      color: #0f6cbd !important;
      font-weight: 600 !important;
      text-decoration: none !important;

      &:hover {
        text-decoration: underline !important;
        color: #115ea3 !important;
      }

      &:active {
        color: #0c3b5e !important;
      }
    }
  }

  /* When table fits: fill 100% and distribute column width evenly so last column (e.g. Tags) isn't tiny */
  &[data-auto-fit='true'][data-column-count] :global {
    .fui-DataGrid {
      width: 100% !important;
    }
    .fui-DataGrid .fui-Table {
      width: 100% !important;
    }
    /* Equal base width for all columns; last column gets remainder so it extends to the right edge (no dead strip) */
    .fui-DataGridHeaderCell:not(:last-of-type),
    .fui-DataGridCell:not(:last-of-type) {
      width: calc(100% / var(--data-table-column-count, 1)) !important;
    }
    .fui-DataGridHeader .fui-DataGridRow .fui-DataGridHeaderCell:last-of-type,
    .fui-DataGridBody .fui-DataGridRow .fui-DataGridCell:last-of-type {
      min-width: calc(100% / var(--data-table-column-count, 1)) !important;
      width: auto !important;
    }
  }

  /* Hide resize handle on last column only when table fits (autoFitColumns); when overflow/scroll, last column can resize (Fluent docs) */
  &[data-column-count][data-auto-fit='true'] :global(.fui-DataGridHeader .fui-DataGridRow .fui-DataGridHeaderCell:last-of-type .fui-DataGridHeaderCell__aside) {
    display: none !important;
  }
}

.dataGrid {
  min-width: 0;
}

/* AG Grid-style loading overlay */
.loadingOverlayContainer {
  position: relative;
}

.loadingOverlay {
  position: absolute;
  inset: 0;
  z-index: 2;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding-top: 60px;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(1px);
  pointer-events: all;
  border-radius: var(--borderRadiusMedium, 4px);
}

.loadingOverlayContent {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 16px 24px;
  background: var(--colorNeutralBackground1, #ffffff);
  border: 1px solid var(--colorNeutralStroke1, #c4c4c4);
  border-radius: var(--borderRadiusMedium, 4px);
  box-shadow: var(--shadow4, 0 2px 4px rgba(0, 0, 0, 0.14));
}

.loadingOverlayText {
  font-size: 13px;
  font-weight: 500;
  color: var(--colorNeutralForeground2, #616161);
}

.loadingDimmed {
  opacity: 0.6;
  pointer-events: none;
  transition: opacity 0.15s ease;
}

.emptyStateInGrid {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 20px 16px;
  min-height: 88px;
  min-width: 0;
  width: 100%;
  box-sizing: border-box;
  border-top: 1px solid var(--colorNeutralStroke2, #e0e0e0);
  background-color: var(--colorNeutralBackground2, #fafafa);
}

.emptyStateInGridMessageSticky {
  position: sticky;
  left: 50%;
  transform: translateX(-50%);
  display: inline-flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.emptyStateInGridIcon {
  font-size: 24px;
  margin-bottom: 8px;
  opacity: 0.6;
}

.emptyStateInGridTitle {
  font-size: 14px;
  font-weight: 600;
  color: var(--colorNeutralForeground1, #242424);
  margin-bottom: 4px;
}

.emptyStateInGridMessage {
  font-size: 13px;
  color: var(--colorNeutralForeground2, #616161);
  max-width: 100%;
  line-height: 1.5;
}

.emptyStateInGridLink {
  background: none;
  border: none;
  color: var(--colorBrandForeground1, #0f6cbd);
  text-decoration: underline;
  cursor: pointer;
  padding: 0;
  font-size: inherit;
  font-family: inherit;

  &:hover {
    color: var(--colorBrandForeground1Hover, #115ea3);
  }
}

/* Empty state: hide body, keep header and empty message */
.tableWrapper[data-empty='true'] :global(.fui-DataGrid) tbody {
  display: none;
}

/* Empty state: no extra bottom border (header row is last row, remove its border-bottom) */
.tableWrapper[data-empty='true'] :global(.fui-DataGridHeader .fui-DataGridRow) {
  border-bottom: none !important;
}
